"""Creates a train-test dataset splits.

Author: Patrik Goldschmidt
Date: 19.09.2022

Use the variables in "Program Settings" source code section to customize the
program and create a dataset based on given PCAP and its statistics
The script requires a statistics file created by tshark regarding the given
PCAP to exist. If it does not, use the following command:
tshark -r <file.pcap> -q -z ip_srcdst,tree > <file.ipstats>

Usage:
python dataset_create.py
"""

import os
import random
import scapy
import scapy.utils

from typing import Optional
from scapy.layers.inet import IP
from scapy.layers.inet6 import IPv6


###############################################################################
############################   Program Settings   #############################
###############################################################################
# Files containing PCAP and their IP statistics generated by tshark
#PCAP_DATA  = '/data/evaldset/caida2007_ddos/workinprog/to-victim_merged.pcap'
#PCAP_STATS = '/data/evaldset/caida2007_ddos/workinprog/to-victim_merged.ipstats'
PCAP_DATA  = '/data/evaldset/caida2007_ddos/workinprog/elwork/ddostrace.to-victim.20070804_134936.pcap'
PCAP_STATS = '/data/evaldset/caida2007_ddos/workinprog/elwork/ddostrace.to-victim.20070804_134936.ipstats'

# Filename of IP addresses to ignore when creating train-test splits
# Use None or empty string if no ignored IPs have to be specified
# Format of the file is IP1<space>IP2<space>IPN<newline> as generated by this program
#IGNORE_IPS_FILENAME = '/data/evaldset/caida2007_ddos/workinprog/ddostrace.to-victim.20070804_134936_test_ips.txt'
IGNORE_IPS_FILENAME = None

# How many IPs to include in train and test sets
TRAIN_IPS_CNT  = 8
TEST_IPS_CNT   = 3

# Minimum and maximum number of packets eligible for selection into train/test data
SELECTION_PKTS_MIN = 1000
SELECTION_PKTS_MAX = 20000

# If true, only IP addresses for train and test splits are returned
RETURN_IPS_ONLY  = False
DUMP_IPS_DIVISON = True

# Technique for IP addresses selection
# Available options: random, mostactive, leastactive
# Note that when the number of available IPs is lesser than
IP_SELECTION_TECHNIQUE = 'mostactive'


###############################################################################
#############################   Program itself   ##############################
###############################################################################
def extract_src_ip(pkt) -> Optional[str]:
    src_ip = None

    if pkt.haslayer(IP):
        src_ip = pkt[IP].src
    elif pkt.haslayer(IPv6):
        src_ip = pkt[IPv6].src

    return src_ip


def parse_ipstats(ipstats_lst : list) -> dict:
    resultdict = {}

    # Skip the first 7 lines
    ipstats_lst = ipstats_lst[5:]

    for ipstats_line in ipstats_lst:
        ipstats_words = ipstats_line.split()

        # Solve specific cases of the tshark's output
        if ipstats_words[0] == 'Source':
            # All IPv4 addresses have been processed let's go for IPv6
            continue
        elif ipstats_words[0] == 'Destination':
            # Break the loop upon reading all source IP addresses
            break

        ip = ipstats_words[0]
        pkts = int(ipstats_words[1])

        resultdict[ip] = pkts

    return resultdict


def split_traintest_ips(ipstats_dict : dict, ips_ignore : set) -> tuple:
    # Apply filters to obtain dict of usable IPs
    ipstats_dict = {ip : pkts for ip, pkts in ipstats_dict.items() if pkts >=
        SELECTION_PKTS_MIN and pkts <= SELECTION_PKTS_MAX}
    ips = list(ipstats_dict.keys())

    # Initialize IP sets
    train_ips = set()
    test_ips  = set()

    # Compute rounded ratio of test/train subets and add counters
    train_test_rratio = round(TRAIN_IPS_CNT / TEST_IPS_CNT)

    # Modify the list of IP addresses based on selection technique
    if IP_SELECTION_TECHNIQUE == 'leastactive':
        ips = reversed(ips)
    elif IP_SELECTION_TECHNIQUE == 'random':
        random.shuffle(ips)

    for ip in ips:
        # Ignore IP address if it is present in the set of ignored IPs
        if ip in ips_ignore:
            continue

        # If one (or both) counts are reached, fill in the remaining one and exit
        if len(train_ips) == TRAIN_IPS_CNT or len(test_ips) == TEST_IPS_CNT:
            while len(train_ips) != TRAIN_IPS_CNT:
                train_ips.add(ip)

            while len(test_ips) != TEST_IPS_CNT:
                test_ips.add(ip)

            break

        # Counts are not reached yet, decide which set to fill
        if (len(train_ips) + len(test_ips)) % (train_test_rratio + 1) != train_test_rratio:
            train_ips.add(ip)
        else:
            test_ips.add(ip)

    # In some cases, such as providing ignored IPs, a situation when the maximum
    # rounded ratio is highly exceeded, may occur, this IF tends to fix it
    if len(train_ips) / len(test_ips) >= 2 * train_test_rratio:
        firstip = list(train_ips)[0]
        train_ips.remove(firstip)
        test_ips.add(firstip)

    return train_ips, test_ips


def main() -> None:
    ips_stats   = {}
    ips_ignored = set()

    # Open a file with IPs communication statistics
    with open(PCAP_STATS, 'r') as statsfile:
        ips_stats = parse_ipstats(statsfile.readlines())

    # Open a file with ignored IP addresses, if any
    if IGNORE_IPS_FILENAME is not None and IGNORE_IPS_FILENAME != '':
        with open(IGNORE_IPS_FILENAME, 'r') as ipsfile:
            ips_ignored = set(ipsfile.read().split())

    # Split the parsed IP stats into train & test subsets
    ips_train, ips_test = split_traintest_ips(ips_stats, ips_ignored)

    # Save train-test IP divisions to the file
    with open(os.path.splitext(PCAP_DATA)[0] + '_train_ips.txt', 'w') as train_ips_file:
        train_ips_file.write(' '.join(list(ips_train)) + '\n')

    with open(os.path.splitext(PCAP_DATA)[0] + '_test_ips.txt', 'w') as test_ips_file:
        test_ips_file.write(' '.join(list(ips_test)) + '\n')

    if RETURN_IPS_ONLY:
        return

    # Open file handles for PCAP reading/writing
    pcap_reader  = scapy.utils.PcapReader(PCAP_DATA)

    if TRAIN_IPS_CNT > 0:
        pcap_writer_train = scapy.utils.PcapWriter(os.path.splitext(
            PCAP_DATA)[0] + '_train.pcap', nano=True)

    if TEST_IPS_CNT > 0:
        pcap_writer_test = scapy.utils.PcapWriter(os.path.splitext(
            PCAP_DATA)[0] + '_test.pcap', nano=True)

    # Iterate through the PCAP file and apply the previous IP division for packet selection
    for pkt in pcap_reader:
        # Determine packet source IP
        src_ip = extract_src_ip(pkt)

        # Place the packet based on the source IP address to the desired packet set
        if src_ip in ips_train:
            pcap_writer_train.write(pkt)
        elif src_ip in ips_test:
            pcap_writer_test.write(pkt)
        else:
            continue

    pcap_reader.close()
    pcap_writer_train.close()
    pcap_writer_test.close()


if __name__ == '__main__':
    main()
